# Теория по конечным автоматам

## Общая информация

**Опр**. **Конечным автоматом** называется пятерка $A=(X, S, Y, h, f)$, где $X$ - множество входных символов (входной алфавит), $S$ - множество состояний (внутренний алфавит), $Y$ - множество выходных символов (выходной алфавит), $h: S \times X \rightarrow S$ - функция переходов, $f: S \times X \rightarrow Y$ - функция выходов.

Задавать можно графом, таблицами переходов и выходов.

**Опр.** **Регистром сдвига** называют автомат $(X,Z^n,Y,h,f)$, где

- $h((z_1,...,z_n),x)=(z_2,...,z_n,\varphi(z_1,...,z_n,x))$
- $f((z_1,…,z_n),x) = \psi(z_1,…,z_n,\varphi(z_1,…,z_n,x))$
- $\varphi: Z^n\times X \to Z$
- $\psi: Z^n \times X \to Y$

## Task 1

### Общая теория

Представляем автомат в виде графа: $G = (V, E \subset V^2)$

**Опр.**. На множестве $V$ определяется **отношение связности**: $V_1 \sim V_2$ тогда и только тогда, когда существует цепь, соединяющая $V_1$ и $V_2$ через конечное число вершин. Является отношением эквивалентности, поэтому $V$ разбивается на непересекающиеся классы эквивалентности, которые называются **компонентами связности**.

В контексте автоматов компонента связности - подавтомат автомата.

### Алгоритм поиска компонент связности графа

Используется алгоритм обхода в глубину (DFS).

1. Инициализируем массивы для посещенных вершин и компонент связности.
2. Начинаем итерироваться по вершинам, которые еще не посетили.
3. Добавляем очередную вершину в посещенные и текущую компоненту связности.
4. Дальше смотрим на соседние вершины, в которые мы можем попасть из текущей. Если мы еще не были в соседней вершине, то в пункт 3.
5. Все вершины, которые обошли, образуют компоненту связности. Далее переходим к еще не посещенной вершине и переходим в пункт 3.

## Task 2

### Общая теория

Представляем автомат в виде графа: $G = (V, E \subset V^2)$

**Опр.**. На множестве $V$ определяется **отношение сильной связности**: $V_1 \approx V_2$ тогда и только тогда, когда:

- $\exist$ путь, соединяющий $V_1$ и $V_2$;
- $\exist$ путь, соединяющий $V_2$ и $V_1$.

Является отношением эквивалентности, поэтому $V$ разбивается на непересекающиеся классы эквивалентности, которые называются **компонентами сильной связности**.

В контексте автоматов компонента связности - подавтомат автомата.

### Алгоритм поиска компонент сильной связности графа

Используется алгоритм Косарайю. Этот алгоритм выполняется в два основных этапа: первый обход графа для определения порядка вершин, а затем второй обход транспонированного графа в этом порядке. Рассмотрим подробное описание работы алгоритма.

1. Инвертируем дуги исходного ориентированного графа.
2. Запускаем поиск в глубину на исходном графе, запоминая, в каком порядке выходили из вершин.
3. Запускаем поиск в глубину на обращенном графе, в очередной раз выбирая непосещённую вершину с максимальным номером в векторе, полученном в п.2.
4. Полученные из п.3 деревья и являются сильно связными компонентами.

## TASK 3

### Общая теория

**Опр.** Состояния $s_1$ и $s_2$ автомата $\mathcal A=(X,S,Y,h,f)$ называются **$k$-эквивалентными** $(k\in\N_0)$, если $\forall \overline x\in X^k:\mathcal A_{s_1}(\overline x)=\overline y=y_1,y_2,...,y_k=\mathcal A_{s_2}(\overline x)$.

Обозначается: $s_1 \underset{k}{\sim} s_2$

**Опр.** **Фактор автомат** $\mathcal A/_\sim$ называется  **минимальной (приведенной) формой** автомата $\mathcal A$.

**Опр.** Мощность $|S/_\sim|=\mu(\mathcal A)$ — **приведенный вес** автомата $\mathcal A$.

Автомат $\mathcal A$ минимальный, если $\mu(\mathcal A)=|S|\iff S/_\sim=S\iff \mathcal A/_\sim=\mathcal A$.

По сути приведенный вес автомата - число компонент связности в последнем k-классе, а степень различимости (дельта) - это k.

### Алгоритм построения минимальной формы автомата

**Вход**: автомат $A=(X,S,Y,h,f)$.

**Шаг 1**: По таблице выходов определить разбиение $S=S_1\cup...\cup S_{r_1}$. По-человечески - разбиваем состояния на множества, у которых одинаковые пси.

**Шаг k+1**: Для всех пар $S_1, S_2\in S_{k-1,i}$ при подаче всех $x\in X$ смотрим $h(s_1,x)$ и $h(s_2,x)$ лежат в одном $S_{k-1,j}$ или нет. В первом случае $S_1\underset{k}{\sim} S_2$, а во втором $S_1\cancel{\underset{k}{\sim}} S_2$.

Если разложение $S$ на классы $k$ эквивалентности совпадает с разложением на классы $k-1$ эквивалентности, то строим разложение $S$ на классы эквивалентности. В противном случае переходим на следующий шаг.

**Выход**: Разбиение $S$ на классы эквивалентных состояний.

У нас в коде метод *get_first_classes* нужен для разбиения на классы 1-эквивалентности.

Метод *is_in_one_equal_class* определяет, находились ли два состояния в одном классе k-1-эквивалентности, т.е. на предыдущем шаге.

Метод *step_split_class* делит текущий подкласс эквивалентности на подмножества, проверяя каждое состояние с первым состоянием в текущем классе. Если состояние удовлетворяет условию эквивалентности, добавляет его в новый класс. То есть по сути образуется два множества - которые точно эквиваленты друг и друг, и остальные.

Метод *split_class* разбивает класс эквивалентности на подмножества до тех пор, пока не будут обработаны все состояния.

Метод *compute_k_clazzes* вычисляет k-классы эквивалентности.

Метод *get_equivalence_classes* - основной - объединяет предыдущий код.

## Task 4

### Общая теория

**Опр.** Функция $\pi : X^{m+1} \times Y^n \to Y$ называется функцией памяти автомата $\mathcal A=(X,S,Y,h,f)$, если $\forall s\in S ~~\forall t\geq max\{m,n\} ~~\forall \bar x=x_1,…,x_t$ выполняется $\mathcal A_s(x_1,…,x_t) = y_1,…,y_t \Rightarrow \pi (x_{t-m}, …,x_t, y_{t-n},…,y_{t-1}) = y_t$.

Другими словами, выходной символ определяется по значению предыдущих $m$ входных, $n$ выходных и текущего входного.

**Опр.** Памятью автомата $\mathcal A$ называется величина $m(\mathcal A) = \underset{\pi}{\min} \max\{m,n\}$, т.е. размер самой маленькой зависимости.

Если у автомата $\mathcal A$ нет ни одной функции памяти, то говорят, что у $\mathcal A$ бесконечная память и обозначают $m(\mathcal A) = \infin$. 


### Алгоритм нахождения памяти произвольного автомата

**Шаг 0**: Построить минимальную форму автомата $\mathcal A$. Для этого берем разбиение автомата на классы k-эквивалентности и оставляем в каждом подклассе одно любое состояние. В таблице и графе также меняем состояния из подклассов на то, что оставили.

**Шаг 1**: для каждого состояния $s_i$ находим $Q_1$ - множество всех ребёр, которые входят в это состояние. Если одинаковых ребер несколько, то оставляем одно рандомное.

Если $\exists i\neq j: Q_1(s_i) \cap Q_1(s_j) \neq \emptyset$, то переходим на следующий шаг.

Шаг $k$. Вычисляем $Q_k(s_i)=\{(x_1,...,x_k,y_1,...,y_k)\;|\; \exist s'\in S\;\; h(s', x_1,...,x_k)=s;\; f(s', x_1,...,x_k)=y_1,...,y_k\}$ 

Если $Q_k(s_i)\cap Q_k(s_j) = \emptyset~~ \forall i\neq j$, то $m(A)\leq k$ функция памяти $\pi$ определяется по правилу $\pi(x_1, …, x_k, x_{k+1}, y_1,…,y_k) = f(s_i, x_{k+1})$, где состояние $s_i$ однозначно определяется условием $(x_1,…,x_k, y_1,…,y_k)\in Q_k(s_i)$.

Если по-человечески, то рассмотрим на примере k=2. Берем ребро, которое заходит в $s_i$, определяем состояние $s_j$, из которого исходит это ребро в $s_i$, далее в $Q_2(s_i)$ записываем слева ребра, которые входят в $s_j$, а справа то, что уже было в $s_i$.


Для формирования большой таблицы выписываем все возможные элементы из $Q_k(s_i)$. Если такой элемент есть, то смотрим, что получится на выходе автомата, если на него подать 0 и 1. И записываем эти значения в соответствующие поля таблицы истинности. Иначе там просто * - то есть либо 0, либо 1.

Далее по вектору функции памяти $y_i$ строим многочлен Жегалкина. Все.

## TASK 5

### Общая теория

**Опр.** Пусть $P$ — поле. Последовательность $u\in P^\infin$ называют **линейной рекуррентной последовательностью порядка** $m$ над полем $P$, если $\exists c_0,…,c_{m-1}\in P$:

$$
u_{i+m}=c_{m-1}u_{i+m-1} + ... + c_0 u_i, ~~~i\geq 0
$$

Описанный закон называют **законом рекурсии ЛРП** $u$.

**Опр.** Многочлен $f(x)=x^m-c_{m-1}x^{m-1}-...-c_0$ называют **характеристическим многочленом** ЛРП $u$.

**Опр.** **Минимальным многочленом** ЛРП $u$ называют характеристический многочлен наименьшей степени. ПРи умножении ЛРП $u$ на минимальный многочлен ЛРП обнуляется. Минимальный многочлен является единственным.

**Опр.** Степень $\deg m_u(x)$ этого минимального многочлена называют **рангом ЛРП** $u$ и обозначают $\text{rank}~ u$.

**Опр.** **Суммой отрезков** $u(\overline{0, l-1})$ и $v(\overline{0, m-1})$ называют отрезок $(u+v)(\overline{0,\min(l;m)-1})$. (Эта одна ЛРП, у которой элементы - попарная сумма элементов двух ЛРП)

**Опр.** **Умножение отрезка $u(\overline{0, l-1})$ на многочлен** $x^s$ — это отрезок $(x^su)(\overline{0, l-s-1})$. (То же самое ЛРП, но сдвинутое влево на $s$ позиций)

**Опр.** **Умножение отрезка** $u(\overline{0, l-1})$ **на произвольный многочлен** $f(x) = \sum_{s=0}^m f_sx^s$ — это отрезок $(f(x)u)(\overline{0, l-m-1}) = \sum_{s=0}^m f_s (x^su)(\overline{0,l-s-1})$. (После умножение на $x^s$ будет несколько отрезков разной длины, их далее необходимо между собой сложить. Получится отрезок с минимальной длиной)

### Алгоритм Берлекемпа-Месси

**Вход**: Отрезок $u(\overline{0, l-1})$

Нужно будет формировать таблицу:

|Номер шага $s$|Отрезок|Многочлен|Количетсво нулей в отрезке|
|---|---|---|---|
|0|$u(\overline{0, l-1})$|$f_0=1$|k_0|
|0|$u(\overline{0, l-2})$|$f_0=x+...$|k_1|
...
|0|$u(\overline{0, l-1-s})$|$f_0=x^s+...$|k_s|

**Шаг 0**: В таблицу записываем отрезок $u_0(\overline{0, l-1}) = u(\overline{0, l-1})$. $F_0(x) = 1$. При этом $u_0(\overline{0, l-1})=F_0(x) \cdot u(\overline{0, l-1})$.

Если $u_0(\overline{0, l-1}) = \bar 0$, то $F_0(x)=1$ — минимальный многочлен и СТОП. В противном случае переходим на следующий шаг.

**Шаг $1 \le s < l$**: Пусть на шаге $s-1$ получен отрезок $u_{s-1}(\overline{0, l-s}) = f_{s-1}(x) \cdot u(\overline{0, l-1})$. Положим $u^{0}_{s}(\overline{0, l-1-s})=x \cdot u_{s-1}(\overline{0, l-s})$ и $F_s^{(0)}(x) = xF_{s-1}(x)$ и $k^{0}_{s}=k_{s-1}-1$

Полагаем $i=0$, возможно три шага:

1. Если $u_{s}^{i}(\overline{0, l-1-s})$ - нулевой отрезок, то СТОП и алгоритм выдает $F_{s}^{i}(x)$ - минимальный многочлен.
2. Проверяем, существует ли $t\in \overline{0,s-1}: k_t=k_{s}^{i}$ (то есть смотрим на текущее число нулей и смотрим, было ли такое уже в таблице). Если такого $t$ не существует, то полагаем $u_{s}(\overline{0, l-1-s})=u_{s}^{i}(\overline{0, l-1-s}), F_s(x)=F_s^{i}(x), k_s=k_{s}^{i}$, то есть завершаем шаг $s$ и переходим на следующий шаг.
3. Если $k_t=k_{s}^{i}$, то вычисляем $r=-u_{s}^{i}(k_t) \cdot u_{t}(k_t)^{-1}$ (т.к. двоичный регистр, то - уходит, нужно взять значение в ЛРП $u_{t}$ с индексом $k_t$, второй множитель - всегда будет единицей, т.к. обратного в $Z_2$ для нуля нет) и полагаем $u_{s}^{i+1}(\overline{0, l-1-s})=u_{s}^{i}(\overline{0, l-1-s}) + r \cdot u_t(\overline{0, l-1-s})$, а также $f_{s}^{i+1}(x)=f_{s}^{i}(x) + r \cdot f_t(x)$. Увеличиваем $i$ на единицу и переходим к действию 1.

**Шаг $l$**. Если алгоритм не завершит работу на шаге $l-1$, то выполняем следующее. Вычисляем $u_l=x \cdot u_{l-1}$ - получится нулевой, и $f_l(x)=x \cdot f_{l-1}(x)$ - минимальный многочлен отрезка $u(\overline{0, l-1})$
